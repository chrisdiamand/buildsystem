#!/usr/bin/env python3

import os
import sys

builddir = "Build"

def exec_file(fname, globs, locs = None):
    with open(fname, "r") as fp:
        code = compile(fp.read(), fname, "exec")
        exec(code, globs, locs)

class Target:
    def gen(self, fp):
        print("Error: gen() method not implemented in class",
              self.__class__.__name__)
        sys.exit(1)

    def getMakeTarget(self):
        print("Error: getMakeTarget() method not implemented in class",
              self.__class__.__name__)
        sys.exit(1)

    def getMakeDeps(self):
        ret = ""
        for i in self.deps:
            t = i.getMakeTarget()
            assert t != None
            assert type(t) == str
            if t.isspace():
                continue
            ret += " " + t
        return ret

# A python module used to write Makefile rules for
# a particular target type e.g. Jars/C executables/etc.
class BuildTarget:
    module_globals = {"builddir"   :   builddir,
                      "Target"     :   Target}
    def __init__(self, fname):
        # The name for a target of this type e.g. 'Jar'/'CProg'
        self.modulename = os.path.splitext(os.path.basename(fname))[0]
        # The python file containing the relevant classes
        self.fname = fname

        # A helper function to write pattern rules
        self.write_rule = None
        # The class used by the 'project.py' script
        self.decl_class = None

        self.load()

    def load(self):
        exec_file(self.fname, self.module_globals)
        self.decl_class = self.module_globals[self.modulename]

# Look through the targets/ directory for scripts defining
# target types. Return an array of BuildTarget instances.
def load_target_types(project_globals):
    ret = []
    script_loc = os.path.realpath(sys.argv[0])
    script_loc = os.path.dirname(script_loc)
    targets_dir = os.path.join(script_loc, "targets")
    for target in os.listdir(targets_dir):
        script = os.path.join(targets_dir, target)
        if os.path.splitext(script)[1] != ".py":
            continue
        bt = BuildTarget(script)
        project_globals[bt.modulename] = bt.decl_class
        ret.append(bt)
    return ret

class Makefile(Target):
    def __init__(self, deps):
        self.deps = deps

    def gen(self, fp):
        fp.write("# Autogenerated by " + sys.argv[0] + " - do not edit\n\n")
        fp.write(".PHONY: all\n")
        fp.write("all: " + self.getMakeDeps() + "\n\n")

        # Make sure the build directory exists
        fp.write(builddir + ":\n")
        fp.write("\t@mkdir -p " + builddir + "\n\n")

        # make clean
        fp.write(".PHONY: clean\n")
        fp.write("clean:\n")
        fp.write("\t@rm -Rf $(REMOVE_FILES) "
                      + builddir + "\n\n");

# Walk the dependency tree
def generate(target, outfile):
    assert issubclass(target.__class__, Target)
    if "__generated__" in target.__dict__:
        return
    else:
        target.__generated__ = True
    target.gen(outfile)
    if not "deps" in target.__dict__:
        print("Error: No such field `deps' in class",
              target.__class__.__name__)
        sys.exit(1)
    if target.deps == None:
        return
    for i in target.deps:
        generate(i, outfile)

# Set up a namespace containing classes 'project.py' can use
# to define Makefiles
project_globals = {"Makefile":   Makefile}

# Load the target definition scripts and add their classes
# into the project.py namespace
target_types = load_target_types(project_globals)

# Load the project definition from 'project.py'.
try:
    exec_file("project.py", project_globals)
except IOError as e:
    print("Error: " + e.strerror + ": '" + e.filename + "'")
    sys.exit(1)

makefile = project_globals["makefile"]

# Generate the Makefile.
outfile = open("Makefile", "w")
generate(makefile, outfile)

for bt in target_types:
    if bt.write_rule != None:
        bt.write_rule(outfile)

outfile.close()
